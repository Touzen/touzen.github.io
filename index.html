<html>
    <head>
        <link rel="stylesheet" href="style.css" />
        <title>Thomas Vakili - PhD student at Stockholm University</title>
        <meta name="viewport" content="width=550" />
        <script>
            const drawCircle = (ctx, startX, startY, radius, color) => {
                ctx.beginPath();
                ctx.moveTo(startX, startY - radius);
                ctx.fillStyle = color;
                ctx.arc(startX, startY, radius, 0, Math.PI * 2, true); // Outer circle
                ctx.fill();

            }

            const drawTriangle = (ctx, pointX, pointY, color) => {
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.moveTo(pointX, pointY);
                ctx.lineTo(pointX - 270, pointY - 200);
                ctx.lineTo(pointX - 335, pointY - 90);
                ctx.lineTo(pointX, pointY);
                ctx.fill();
            }

            const calculateCoefficient = () => {
                const headerOffset = document.getElementById('home').offsetHeight;

                const yOffset = window.pageYOffset;
                const hero = document.getElementById('hero');
                const firstHeading = document.getElementById('publications');

                return yOffset/(hero.offsetTop + hero.offsetHeight + 200 - headerOffset);
            }

            const stickySections = () => {
                const [header] = document.getElementsByTagName('header');
                const [publications, contact] = document.getElementsByClassName('sticky');

                const vhScaleDivisor = document.documentElement.clientHeight / 100;

                const headerHeight = header.offsetHeight / vhScaleDivisor;
                
                const publicationHeight = publications.offsetHeight / vhScaleDivisor;
                const publicationOffset = 50 - publicationHeight - headerHeight - 5;

                const contactHeight = contact.offsetHeight / vhScaleDivisor;
                const contactOffset = 50 - contactHeight - headerHeight - 5;

                const publicationsBottom = (publications.offsetTop + publications.offsetHeight - publications.style.paddingBottom);
                const distance = publicationsBottom - contact.offsetTop;
                const vhDistance = distance / vhScaleDivisor;

                publications.style.marginTop = `-${distance}px`;
                publications.style.top = `${publicationOffset}vh`;
                contact.style.top = `${contactOffset}vh`;

                console.log(vhDistance);
            }

            const drawPiercingTriangle = (ctx) => {
                const coefficient = calculateCoefficient();

                const radius = 200;

                const maxX = window.innerWidth - radius;
                const maxY = window.innerHeight - radius;

                // startX and startY could be set to something more linearly appropriate
                const picture = document.getElementById("hero").firstElementChild;
                const startX = -picture.x;
                const startY = -picture.y;

                const xDistanceToMax = maxX - startX;
                const x = Math.min(startX + xDistanceToMax * coefficient, maxX);

                const yDistanceToMax = maxY - startY;
                const y = Math.min(startY + yDistanceToMax * coefficient, maxY);

                const colorCoefficient = Math.max(0, coefficient - 1) * 5;
                const color = 255 * Math.min(colorCoefficient, 1);

                drawTriangle(ctx, x, y, 'rgb(255, ' + color + ', ' + color + ')');
            }

            const drawMainCircle = (ctx) => {
                const coefficient = calculateCoefficient();

                const radius = 200;

                const maxX = window.innerWidth - radius;
                const maxY = window.innerHeight - radius;

                const picture = document.getElementById("hero").firstElementChild;

                const startX = picture.x + 300;
                const xDistanceToMax = maxX - startX;
                const x = Math.min(startX + xDistanceToMax * coefficient, maxX);

                const startY = picture.y + 150;
                const yDistanceToMax = maxY - startY;
                const y = Math.min(startY + yDistanceToMax * coefficient, maxY);

                const color = 255 * coefficient;

                const radiusCoefficient = Math.pow(Math.max(coefficient, 1), 5); 
                const scaledRadius = Math.min(
                    radius * radiusCoefficient,
                    window.innerHeight * 2
                );

                drawCircle(ctx, x, y, scaledRadius, 'rgb(255, ' + color + ', ' + color + ')');
            }

            const updateColors = () => {
                const coefficient = calculateCoefficient();
                const colorCoefficient = 10 * Math.pow(Math.max(coefficient, 1), 10); 
                
                const colorShift = Math.min(255 - colorCoefficient, 255);

                const backgroundColor = `rgb(${255 - colorShift}, ${255 - colorShift}, ${255 - colorShift})`;
                const textColor = `rgb(${colorShift}, ${colorShift}, ${colorShift})`;

                const body = document.getElementsByTagName('body')[0];
                body.style.color = textColor;
                body.style.backgroundColor = backgroundColor;

                const header = document.getElementsByTagName('header')[0];
                header.style.backgroundColor = backgroundColor;
            }

            const draw = () => {
                var canvas = document.getElementById("background");
                var ctx = canvas.getContext("2d");
                ctx.canvas.width  = window.innerWidth;
                ctx.canvas.height = window.innerHeight;

                window.requestAnimationFrame((_) => {
                    drawMainCircle(ctx);
                    drawPiercingTriangle(ctx);
                    updateColors();
                    stickySections();
                });
            }

            document.addEventListener('DOMContentLoaded', (e) => draw() );
            document.addEventListener('scroll', (e) => draw() );
            window.addEventListener('resize', (e) => draw() );
        </script>
    </head>
    <body>
        <canvas id="background"></canvas>
        <header id="home">
            <div id="title">
                <a href="#hero">
                <h1 class="title">
                    Thomas Vakili
                </h1>
                <p id="byline">PhD student at Stockholm University</p>
                </a>
            </div>
            <nav>
            <ol>
                <li><a href="#hero">Home</a></li>
                <li><a href="#publications">Publications</a></li>
                <li><a href="#contact">Contact</a></li>
            </ol>
            </nav>
        </header>
        <div id="hero">
            <img src="images/thomas.png" alt="Picture of Thomas at the Bendery Fortress."/>
            <section id="introduction">
            <p>Thomas Vakili is a PhD student at the <a target="_blank" href="https://dsv.su.se/en/">Department of Computer and Systems Sciences</a> at <a target="_blank" href="https://www.su.se/english/">Stockholm University</a>. The focus of his research is Natural Language Processing. He is part of the <a target="_blank" href="https://dsv.su.se/en/research/research-areas/language/projects/2.58013/dataleash-learning-and-sharing-under-privacy-constraints-1.443501">DataLEASH</a> project and his supervisor is <a target="_blank" href="https://people.dsv.su.se/~hercules/">Professor Hercules Dalianis</a>.</p>

            <p>He has a M.Sc. in computer science and engineering (civ.ing. i datateknik) from <a target="_blank" href="https://kth.se">KTH Royal Institute of Technology</a>. He also has industry experience from working as a IT consultant, primarily as a back-end developer and data engineer.</p>
            </section>
        </div>
        <section id="publications">
            <div class="sticky">
            <p>Thomas Vakili is a PhD student at the <a target="_blank" href="https://dsv.su.se/en/">Department of Computer and Systems Sciences</a> at <a target="_blank" href="https://www.su.se/english/">Stockholm University</a>. The focus of his research is Natural Language Processing. He is part of the <a target="_blank" href="https://dsv.su.se/en/research/research-areas/language/projects/2.58013/dataleash-learning-and-sharing-under-privacy-constraints-1.443501">DataLEASH</a> project and his supervisor is <a target="_blank" href="https://people.dsv.su.se/~hercules/">Professor Hercules Dalianis</a>.</p>

            <p>He has a M.Sc. in computer science and engineering (civ.ing. i datateknik) from <a target="_blank" href="https://kth.se">KTH Royal Institute of Technology</a>. He also has industry experience from working as a IT consultant, primarily as a back-end developer and data engineer.</p>
            </div>
        </section>
        <section id="contact">
            <div class="sticky">
            <p>I am currently working on to what extent masked language models (such as BERT) leak sensitive information about their training data. Since BERT-style models are very common, especially for lesser-resourced languages, this could have significant privacy implications.</p>
            <p>Don't hesitate to contact me if you are interested in collaborating!</p>
            </div>
        </section>
        <section id="links">
            <a target="_blank" href="https://www.linkedin.com/in/thomasvakili/">
            <img src="https://content.linkedin.com/content/dam/me/brand/en-us/brand-home/logos/In-Blue-Logo.png.original.png" alt="LinkedIn logo" />
            </a>
            <a target="_blank" href="https://github.com/Touzen">
            <img src="images/github.png" alt="GitHub mark" />
            </a>
            <a href="mailto:thomas.vakili@dsv.su.se">
            <img src="images/email.svg" alt="Email icon" />
            </a>
        </section>
    </body>
</html>
